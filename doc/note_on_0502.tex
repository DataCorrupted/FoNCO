\documentclass[10pt]{article}
\usepackage[pdftex]{graphicx, color}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{tikz}
\usetikzlibrary{automata,positioning}

\headheight 8pt \headsep 20pt \footskip 30pt
\textheight 9in \textwidth 6.5in
\oddsidemargin 0in \evensidemargin 0in
\topmargin -.35in

\lstset{frame=none,
	language=python,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=left,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=4
}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}


\begin{document}
\title{
	Experiment note
}
\author{Rong Yuyang \\
SIST, ShanghaiTech University\\
{\tt\small rongyy@shanghaitech.edu.cn}
}
\maketitle

\section{Introduction}\par
Currently, the algorithm combines trust region and line search. Simplex will solve a sub problem with trust region constrain, the solution of which will be used to update $x_k$ after we impose line search. Trust region will be updated with a lower bound. \par
The parameters used in this experiment are listed below.
	\begin{lstlisting}[language = python]
        self.init_rho = 1;
        self.init_omega = 1e-2;
        self.max_iter = 512;
        self.max_sub_iter = 100;
        self.beta_opt = 0.75;
        self.beta_fea = 0.3;
        self.theta = 0.9;
        self.line_theta =  1e-4;
        self.omega_shrink = 0.7;
        self.eps_opt = 1e-4;
        self.eps_violation = 1e-5;
        self.sub_verbose = False;
        self.rescale = True;
        self.SIGMA = 0.3;               # Trust region update.
        self.DELTA = 0.75;              # Trust region update.
        self.MIN_delta = 1e-5;          # Min trust region.    
        self.MAX_delta = 64;            # Max trust region.
	\end{lstlisting}
We can now slove 85/128 problems.
\section{Freezers}\par
	Some problems stopped update after certain iterations. One cause is that the update direction provided by the sub problem solver is $0$. Thus the whole problem freezes from there on. Such problems include:
	\begin{lstlisting}
	['HS92', 'HS90', 'HS88', 'HS23', 'HS93', 'HS97', 'HS118', 'HS20', 'HS83']
	\end{lstlisting}

	Take HS88 as an example. HS88 has 2 variables and 1 inequality constrain. After the first iteration, cuter will return $A = 0$ and $g = 0$. Simplex's response to such problem is $d_k = 0$, as the initial basis is good enough to terminate simplex. And the whole algorithm stops ever since.
	\begin{lstlisting}
Iter 1:
Initial basis:             *           *     *     *     *
[[ 0.38  0.54 -0.38 -0.54  1.   -1.    0.    0.    0.    0.    0.14] 	Initial table
 [ 1.    0.   -1.    0.    0.    0.    1.    0.    0.    0.    1.  ]
 [ 0.    1.    0.   -1.    0.    0.    0.    1.    0.    0.    1.  ]
 [-1.    0.    1.    0.    0.    0.    0.    0.    1.    0.    1.  ]
 [ 0.   -1.    0.    1.    0.    0.    0.    0.    0.    1.    1.  ]]
 [-0.62  1.54  0.62 -1.54  0.   -1.    0.    0.    0.    0.  ]			z-c
 [ 1.   -1.   -1.    1.    1.    0.    0.    0.    0.    0.  ]			c

x_0 		d_0 		alpha = 0.5, delta = 1
[[ 0.5]		[[-1.]
 [-0.5]] 	 [ 1.]]

Iter 2:
Initial basis:             *           *     *     *     *
[[ 0.    0.    0.    0.    1.   -1.    0.    0.    0.    0.    0.13] 	Initial table
 [ 1.    0.   -1.    0.    0.    0.    1.    0.    0.    0.    0.5 ]
 [ 0.    1.    0.   -1.    0.    0.    0.    1.    0.    0.    0.5 ]
 [-1.    0.    1.    0.    0.    0.    0.    0.    1.    0.    0.5 ]
 [ 0.   -1.    0.    1.    0.    0.    0.    0.    0.    1.    0.5 ]]
 [ 0.    0.    0.    0.    0.   -1.    0.    0.    0.    0.]			z-c
 [ 0.    0.   -0.   -0.    1.    0.    0.    0.    0.    0.]			c
x_1 		d_1 		alpha = 1, delta = 1
[[ 0. ]		[[ 0.] 					# The algorithm stopped ever since.
 [ 0. ]] 	 [ 0.]]

	\end{lstlisting}

	To tackle to problem encountered in HS88, I tried small initial $\delta$, so that it may avoid jumping into such a bad point. But slowly $x_k$ still converges to 0 and leads to $d_k = (+\delta, 0)^T$ and $d_{k+1} = (-\delta, 0)^T$, repeat, and step size is 0. At this time, $r_c = 1$ and other two is 0. 
	\par This leads to 2 question: why $d_k$ has anything to do with $\delta$ and why it won't converge. Especially, in many problems, $d_k$ has some connection to $\delta$, no matter how large(or small) $\delta$ is, which shouldn't.



\section{Slow but steady}\par
	Some problems gets their $\delta$ dropped too much(more often $\delta$ hits the bottom), that it can no longer make progressive steps. \par
	One trait that can be observed from the loggings of these problems is that the violation drops quickly. Within several iterations the violation can decrease to 0, after that $\delta$ takes a deep dive and never come back. \par
	These problems are listed below:
	\begin{lstlisting}
	['HS68', 'HS103', 'HS101', 'HS112', 'HS75', 'HS111', 'HS111LNP', 'HS98']
	\end{lstlisting}
	One intuitive reasoning is that the estimation provided by the subproblem solver is not accurate enough. We increased parameter $\beta_{opt}$ from 0.7 to 0.85, $\beta_{fea}$ from 0.1 to 0.5. But only HS112 is solved. \par
	Another possible approach to prevent delta from dropping is to raise $\sigma$. We raised $\sigma$ from 0.25, which is suggest by most textbooks, to 0.3 and HS75 is solved. But further increasing it to 0.5 shows no effect. \par
	We still can't find a good explanation as to why $\delta$ declines so fast.
	\subsection{Connection}
		One easiest way to prevent $\delta$ from being too small is simply setting the smallest value of $\delta$ to 1 or even bigger. But this won't work, instead, HS98 turned into the problem we mentioned in the section before, where the updated direction become 0 with $r_c = 1$ and other two being 0.
		\par We believe there is a connection between these problems.

\section{Weirdos}
	\subsection{Explosions}
		Problem HS107, HS33, HS36, HS56 and HS37 has exploding KKT. Their KKT rises as the iteration goes on. Thus they are never solved. \par
		One trait is that their $r_{fea}$ is always small(for HS33 and 37, small means -1) while other two is always 1.
	\subsection{HS99EXP Type}
		I couldn't get hands on what exactly HS99EXP is. Jianshan skipped this problem when testing. But my program won't converge on this problem. \par
		HS99EXP won't converge no matter how large $\delta$ is. It always reaches a maximum $\delta$ yes the KKT and violation barely changes. Further more, after some iteration, Simplex will report one sub problem as unbounded.
\end{document}

